---
title:  "汇编复习记录 under prj31"
categories: Codes
---

基于 [三个一工程](https://tieba.baidu.com/p/4935937768?red_tag=0009508146) 第一阶段的复习笔记

代码已上传至 [Github](https://github.com/somnusberg/prj31_assembly_8086)，欢迎勘误（？（你看看有人理你吗

***

# Unit 1 基础知识

## 1.1 机器语言

高低电平驱动各元件工作

来源：机器指令（复杂，不便修改）

## 1.2 汇编语言的产生

冯诺依曼五大结构：**运算器 + 控制器 = CPU，存储，输入系统，输出系统**

汇编语言 -编译器→ 机器语言

编译器的工作过程：编译器识别数据，转换成机器码放到另一个内存中，**此时并不运行汇编的内容**

汇编对计算机的操作是 **原子性** 的（汇编指令和机器码一一对应）体现高级语言和汇编的编译方式不同

语言在编译时不一定经由汇编，由编译器的编译特性决定

## 1.3 汇编语言的组成

汇编指令：**有对应机器码** (核心)

伪指令、其他符号：**无对应机器码**，由编译器识别、执行

## 1.4 存储器

存放指令和数据

= 内存

## 1.5 指令和数据

在计算机中无区别，均为二进制信息，可以实时转化

## 1.6 存储单元

存储器 -*划分*→ 存储单元

一个存储器可以存储 128 个 byte（0-127） **从零开始编号**

信息最小单位：bit/位 没有独立地址 8bit共享一个地址

存储最小单位：byte/字节

## 1.7 CPU对存储器的读写
## 1.8 地址总线
## 1.9 数据总线
## 1.10 控制总线

CPU 想要进行数据的读写，必须和外部器件（芯片）进行三类信息的交互：

  - 地址信息：存储单元的地址

  - 控制信息：器件的选择，读或写的命令

  - 数据信息：读或写的数据

传递途径：总线（导线集合）

外部总线：地址总线（**表示 2^n 个不同的数据**，寻址能力），控制总线，数据总线（**单次传输 n 位数据**）

CPU 工作过程：地址 → 控制信息 → 传送数据

8086CPU 的数据总线宽度为 16，地址总线为 20 根，寻址能力为 1mb

## 1.11 内存地址空间

内存：

  - 和CPU通过总线相连，**通过内存读写命令直接控制**，物理上分离逻辑上连续的存储空间（逻辑连续有没有想到实验 17 哈哈哈）

  - 部分数据不需带电存储

  - 直接交互，区别于端口的间接交互（通过端口读写命令，14 章）


内存地址空间：一个 CPU 可寻址的内存单元的集合,受地址总线宽度的限制

## 1.12 主板

主板: CPU，存储器，外围芯片组，扩展插槽（RAM 内存条，各类接口卡）

通过总线相连

## 1.13 接口卡

CPU ← 总线 - 接口卡 → 外设

## 1.14 各类存储器芯片

存储器：

  - 随机存储器 RAM：可读可写，必须带电存储

     - 主随机存储器：装在主板上 & 插在扩展插槽上，用于存放供 CPU 使用的绝大部分程序和数据

     - 接口卡上的 RAM：暂时存储 eg. 显存

  - 只读存储器 ROM：装有 BIOS（主板和各类接口卡的软件系统，和硬件交互）（只读是硬件层面的）和开机 LOGO 等

## 1.15 内存地址空间

CPU 操作存储器时将它们都当做内存对待


# Unit 2 寄存器

## 2.1 通用寄存器

典型 CPU 的组成

   - 运算器

   - 控制器

   - 寄存器

靠内部总线相连

## 2.5 16 位结构的 CPU

16 位结构 / 16 位机 / 字长为 16 位 =

  - 运算器一次最多可以处理 16 位数据

  - 寄存器的最大宽度为 16 位

  - 寄存器和运算器之间的通路为 16 位

8086 是 16 位机，能够一次性处理、传输、暂时存储的信息的最大长度为 16 位

## 2.6 8086CPU 给出物理地址的方法

物理地址（20 位） = 段地址（16 位） * 16（二进制左移 4 位） + 偏移地址（16 位）

8086CPU 读写内存的过程：

  1. CPU 中的相关部件提供段地址、偏移地址

  2. 两个 16 位地址 - 内部总线 → 地址加法器

  3. 地址加法器 → 一个 20 位地址

  4. 20 位地址 - 内部总线 → 输入输出控制电路

  5. 输入输出控制电路 → 地址总线

  6. 地址总线 → 存储器

## 2.8 段的概念

内存并没有分段，段的划分来自于 CPU

一个段的最大长度为 64kb；仅用偏移地址来寻址最多可寻 64kb 个内存单元

可以用不同的段地址和偏移地址形成同一个物理地址

## 2.10 CS 和 IP

8086CPU 的工作过程：

  1. 把 CS、IP 放入地址加法器得到物理地址

  2. 地址加法器将地址送入输入输出控制电路

  3. 输入输出电路将地址送上地址总线

  4. CS:IP 处的机器指令通过数据总线被送入输入输出控制电路

  5. 输入输出控制电路将机器指令送入指令缓冲器

  6. **IP自加**

  7. 数据送入执行控制器，执行指令

  8. 回到步骤 1

## 8086 的段

我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。定义一段内存的用途，关键在于 CPU 中寄存器的设置，即 CS、IP、SS、SP、DS 的指向

  - 代码段：

    - 将长度为 N（N <= 64kb）的一组代码，存在一组地址连续，起始地址为 16 的倍数的内存单元中，从而定义一个代码段

    - 让代码段中的代码得到执行，必须将 CS:IP 指向所定义的代码段中第一条指令的首地址

  - 数据段：

    - 将一组长度为 N（N <= 64kb）、地址连续、起始地址为 16 的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段

    - 访问数据：可以用 DS 存放数据段的段地址，再根据需要用相关指令访问数据段中的具体单元

  - 栈段：

    - 将一组长度为 N（N <= 64kb）的地址连续，起始地址为 16 的倍数的内存单元，当作栈空间来用，从而定义一个栈段

    - 访问栈段：用 SS:SP 指向我们定义的栈段

    - 一个栈段的最大容量为 64kb（栈空栈满时 SP 相同）


## 8086 的寄存器：14 个

  - 通用寄存器 reg

    - AX BX CX DX base 类 为了向下兼容，可以拆成（XH XL）

    - SI DI index 类 不能拆成 8 位寄存器

  - 段寄存器 sreg

    - CS 代码段寄存器 - IP 指令指针寄存器

      任意时刻，系统从 CS:IP 开始读取一条指令并执行

    - DS 数据段寄存器

    - SS 栈段寄存器 - SP 栈顶指针寄存器

      任意时刻，SS:SP 指向栈顶元素

    - ES 预留段寄存器

  - 标志寄存器 flag

    ```
    15  14  13  12  11  10  9   8   7   6   5   4   3   2   1   0
    X   X   X   X   OF  DF  IF  TF  SF  ZF  X   AF  X   PF  X   CF
    ```


    - ZF 零标志位 运算指令的结果为 0 → ZF = 1

    - PF 奇偶标志位 结果的所有位中 1 的个数为偶数 → PF = 1

    - SF 符号标志位 有符号数运算结果为负（最高位为 1） → SF = 1

    - CF 进位标志位 记录无符号数运算进位或借位值

    - OF 溢出标志位 有符号数运算发生溢出 → OF = 1

      溢出：运算超出有符号数据的表示范围

      8 位：-128 ~ 127

      16 位： -32768 ~ 32767

    - DF 方向标志位 DF = 1 → 串处理指令中每次操作后 si、di 递减

    debug 对标志位的表示：

    标志 | 值为 1 的标记 | 值为 0 的标记
    :-: | :-: | :-:
    OF | OV | NV
    SF | NG | PL
    ZF | ZR | NZ
    PF | PE | PO
    CF | CY | NC
    DF | DN | UP

## 8086 常用指令：（更多信息参见书 p.286）

  - 数据传送指令

    - `mov m, n` 将 n 送入 m 所在位置

      ```
      m = reg → n = idata / reg / 内存单元 / sreg
      m = sreg → n = reg / 内存单元
      m = 内存单元 → n = reg
      不能用于设置 CS, IP 的值，请使用转移指令
      8086 不能将数据直接送入段寄存器，应用一个 reg 进行中转
      两个操作对象的位数应当一致（见 8.5 指明数据尺寸）
       ```

    - `push m` 将 m 中的数据送入栈中

    - `pop m` 从栈顶取出数据送入 m 中

      ```
      m = reg / sreg / 内存单元
      8086CPU 的入栈和出栈操作都是以字为单位进行的
      只修改 SP ，所以栈顶的变化范围最大为 0 ~ FFFFH
      ```
    
    - `pushf` 将标志寄存器的值压栈

    - `popf` 从栈中弹出数据，送入标志寄存器中

      ```
      pushf 和 popf 为直接访问标志寄存器提供了一种方法
      ```

  - 算术运算指令

    - `add m, n` 将 m 和 n 相加后送入 m 所在位置

    - `sub m, n` 将 m - n 送入 m 所在位置

      ```
      add 和 sub 不能操作段寄存器
      给一个寄存器置零可以用 sub m, m（2 bytes，省地儿 2333）或 mov m, 0（3 bytes）
      其余参考 mov
      ```

    - `cmp m, n` 计算 m - n，不保存结果，仅设置 flag

    - `adc m, n` 带进位加法，m = m + n + CF

    - `sbb m, n` 带借位减法，m = m - n - CF

    - `inc reg` (reg) = (reg) + 1

    - `dec reg` (reg) = (reg) - 1

      ```
      inc 和 dec 不影响 CF 位
      ```

    - `div m` 除法指令

      ```
      m = reg / 内存单元
      8 位：  ax / m      int = al  rem = ah
      16 位： (dx ax) / m int = ax  rem = dx
      ```

    - `mul m` 乘法指令

      ```
      m = reg / 内存单元
      8 位：  al * m = ax
      16 位： ax * m = (dx ax)
      ```

  - 逻辑指令

    - `and m, n` 逻辑与指令，按位进行与运算

    - `or m, n` 逻辑或指令，按位进行或运算

      ```
      and 可将操作对象的相应位设为 0，其他位不变  
      or 可将操作对象的相应位设为 1，其他位不变
      ```

    - `shl m, n` 逻辑左移，将 m 中数据左移 n 位

    - `shr m, n` 逻辑右移，将 m 中数据右移 n 位

      ```
      最后移出的一位写入 CF 中
      空位用 0 补充
      n = 1 → 可以直接写
      n > 1 → 必须将移动位数放入 CL 中
      左移一位 → m = m * 2
      右移一位 → m = m / 2
      ```

  - 串处理指令

    - `movsb` 串传送，以字节为单位

    - `movsw` 串传送，以字为单位

    - `rep movsb` && `rep movsw` 重复串传送指令直至 cx = 0

      ```
      ds:[si] → es:[di]
      传送方向取决于 DF
        DF = 1 → 正向（每次操作后 si、di 递增）
        DF = 0 → 反向（每次操作后 si、di 递减）
      ```

  - 端口读写

    - `in al, 端口地址` 从端口地址处读入 8 位数据

    - `in ax, 端口地址` 从端口地址处读入 16 位数据

    - `out 端口地址, al` 向端口地址处写入 8 位数据

    - `out 端口地址, ax` 向端口地址处写入 16 位数据

      ```
      端口地址范围为 0 - 255 时，可以用 idata 表示端口地址
      端口地址范围为 256 - 65535 时，端口地址放在 dx 中
      ```

  - 转移指令

    - 无条件转移指令 jmp

      - `jmp 段地址:偏移地址` (CS) = 段地址， (IP) = 偏移地址

      - `jmp reg` 用 16 位 reg 中的值修改 IP

      - `jmp short 标号` 转到标号处执行指令，段内短转移

      - `jmp near ptr 标号` 转到标号处执行指令，段内近转移

      - `jmp far ptr 标号` 用标号的段地址和偏移地址修改 CS 和 IP，段间转移（远转移）

        (CS) = 段地址（高地址），(IP) = 偏移地址（低地址）

      - `jmp word ptr 内存单元地址` 段内转移

        (IP) = 内存单元地址处开始的一个字

      - `jmp dword ptr 内存单元地址` 段间转移

        (CS) = （内存单元地址 + 2），(IP) = （内存单元地址）

      - `jmp 四位数字:四位数字` 修改 CS:IP，**仅限 debug 使用**

    - 条件转移指令

      - `jcxz 标号` 有条件转移 = if((cx) == 0) jmp short 标号;

      - 检测比较结果的条件转移指令（根据 **无符号数** 结果，常与 cmp 配合）

        - `je` 等于则转移（zf = 1）

        - `jne` 不等于则转移（zf = 0）

        - `jb` 低于则转移（cf = 1）

        - `jnb` 不低于则转移（cf = 0）

        - `ja` 高于则转移（cf = 0 && zf = 0）

        - `jna` 不高于则转移（cf = 1 || zf = 1）

      ```
      所有的有条件转移指令都是短转移
      ```

    - 循环指令 loop

      - `loop 标号` = (cx)--; if(cx != 0) jmp short 标号;

      ```
      所有的循环指令都是短转移
      loop 指令不影响 CF
      ```

    - 过程

      - `ret` 近转移 = pop IP

      - `retf` 远转移 = pop IP；POP CS

      - call

        - `call 标号` 段内转移 push IP；jmp near ptr 标号

        - `call far ptr 标号` 段间转移 = push CS；push IP；jmp far ptr 标号

        - `call 16 位 reg` 段内转移 = push IP；jmp 16 位 reg

        - `call word ptr 内存单元地址` 段内转移 = push IP；jmp word ptr 内存单元地址

        - `call dword ptr 内存单元地址` 段间转移 = push CS；push IP；jmp dword ptr 内存单元地址
    
    - 中断

      - `int n` 触发 n 号中断

        - `int 0` 除法错误 ← 主动引发

          若法算除法错误，则 0 号中断被触发 ← CPU 自动引发

        - `int 1` 单步中断 ← 主动引发

          在执行完一条指令后，若 TF = 1，则单步中断被触发 ← CPU 自动引发

        - `int 2` 不可屏蔽中断的中断类型码固定为 2

        - `int 9` 基本的键盘输入处理，由 BIOS 提供例程
        
        - `int 10h` BIOS 提供，和屏幕输出相关，ah = 子程序编号
        
          - 2 号子程序：设置光标位置

            ```
            dh = 行号
            dl = 列号
            bh = 页数
            ```
          - 9 号子程序：在光标位置显示字符

            ```
            al = 字符 ASCII 码
            bl = 属性（见显存）
            bh = 页数
            cx = 字符重复个数
            ```

        - `int 13h` 磁盘读写，BIOS 提供，ah = 子程序编号

          - 2 号子程序：读扇区

            ```
            al = 扇区数
            ch = 磁道号
            cl = 扇区号
            dh = 磁头号（对于软盘即面号，因为一个面用一个磁头来读写）
            dl = 驱动器号（软驱从 0 开始，0：软驱 A，1：软驱 B；硬盘从 80h 开始，80h：硬盘 C，81h：硬盘 D）
            ex:bx → 接收数据的内存区

            返回参数：
            操作成功 → ah = 0，al = 读入的扇区数
            操作失败 → ah = error code
            ```

          - 3 号子程序：写扇区

            ```
            al = 扇区数
            ch = 磁道号
            cl = 扇区号
            dh = 磁头号（对于软盘即面号，因为一个面用一个磁头来读写）
            dl = 驱动器号（软驱从 0 开始，0：软驱 A，1：软驱 B；硬盘从 80h 开始，80h：硬盘 C，81h：硬盘 D）
            ex:bx → 写入数据的内存区

            返回参数：
            操作成功 → ah = 0，al = 写入的扇区数
            操作失败 → ah = error code
            ```

        - `int 16h` BIOS 提供，ah = 子程序编号

          - 0 号子程序：从键盘缓冲区中读取一个键盘输入

            ```
            返回参数：
            ah = 扫描码
            al = ASCII 码
            ```
            
        - `int 21h` DOS 提供给程序员调用，ah = 子程序编号

          - 4ch 号子程序：程序返回

            ```
            al = 返回值
            ``` 

          - 9 号子程序：在光标位置显示字符串

            ```
            ds:dx = 字符串的首地址
            字符串需以 ‘$’ 结束
            如果字符串比较长，遇到行尾，程序会自动转到下一行开头继续显示
            如果到了最后一行，还能自动上卷一行
            ```

      - `iret` 中断返回

      ```
      在执行完向 ss 寄存器传送数据的指令后，即使发生中断，CPU 也不会响应，这为连续设置 ss 和 sp 指向正确栈顶提供了一个时机，因此编程时应该连续设置 ss 和 sp
      ```

  - 处理机控制指令

    - `sti` 设置 IF = 1

    - `cli` 设置 IF = 0

    - `nop` 空指令，占一个字节

    ```
    这些指令对标志寄存器或其他处理机状态进行设置
    ```


## 8086 debug.exe 总结

### R

  - `r` 查看寄存器内容

  - `r reg` 改变寄存器内容

    可用 `rip` 或 `rcs` 改变 CS、IP 的值

### D

  - `d 段地址:偏移地址` 列出从指定内存单元开始的128个内存单元的内容
    继续 `d` 列出后续内容

  - `d 段地址:起始偏移地址 结尾偏移地址` 查看指定范围的内容

  - `d` 列出 debug 预设的地址处的内容

  - `d sreg:偏移地址` 以 sreg 中的数据为段地址，列出从段地址：偏移地址开始的内存空间中的数据

### E

  - `e 起始地址 数据 数据 数据 ...` 将从起始地址开始的数据改为后面输入的值

  - `e 段地址:偏移地址` 以提问方式逐个修改从某一地址开始的内存单元中的内容

    - 对当前内存单元进行改写 → 输入数据后按空格键

    - 不进行改写 → 直接按空格键

    - 全部内容改写完毕后按 Enter 键结束操作

  - `e sreg:偏移地址` 以 sreg 中的数据为段地址，向从段地址：偏移地址开始的内存空间中写入数据

### U

  - `u 段地址:偏移地址` 查看从指定位置开始的内存中的机器码对应的汇编指令

  - `u sreg:偏移地址` 以 sreg 中的数据为段地址，查看从段地址：偏移地址开始的内存中的机器码对应的汇编指令

### T

  - `t` 执行 CS:IP 指向的指令

    可以连续使用

    执行修改寄存器 SS 的指令时，下一条指令也紧接着被执行 （见单步中断）

### A

  - `a 段地址:偏移地址` 从指定位置开始写入机器指令，以 Enter 结束

  -  `a sreg:偏移地址` 以 sreg 中的数据为段地址，向从段地址：偏移地址开始的内存中写入机器指令，以 Enter 结束

### Q

  `q` 退出 debug

### G

  - `g 偏移地址` 一次性运行直到CS:该偏移地址以前为止的所有代码

    执行后，寄存器恢复程序刚加载时的值，内存更改则保留

### P

  - `p` 执行 int21

  - `p` 执行 loop 中的指令直至 cx = 0


# Unit 3 寄存器（内存访问）

## 3.1 内存中字的存储

CPU 中，用 16 位 reg 存储一个字。高 8 位存放高位字节，低 8 位存放低位字节。

字单元：存放一个字型数据（16 位）的内存单元，由两个地址连续的内存单元组成。起始地址为 N 的字单元简称 N 地址字单元

## 3.6 栈

基本的栈操作：入栈、出栈

栈的操作规则：**LIFO**（后进先出）

## 3.7 CPU 提供的栈机制

入栈 - push，出栈 - pop，**以字为单位** 进行

栈顶指针：**SS:SP** 指向栈顶元素

栈空时，SS:SP 指向 *栈空间最高地址单元的下一个单元*

`push reg` 的执行过程：

  1. SP = SP - 2

  2. 将 reg 中的内容送入 SS:SP 指向的内存单元

入栈时，栈顶从高地址向低地址方向增长

`pop reg` 的执行过程：

  1. 将 SS:SP 指向的内存单元处的内容送入 reg 中

  2. SP = SP + 2

## 3.8 栈顶超界的问题

发生栈顶超界的情况：

  1. 栈满时使用 push 入栈

  2. 栈空时使用 pop 出栈

然而 8086CPU 并不保证我们对栈的操作不会超界，所以要自己注意

恢复数据时，出栈的顺序要和入栈的顺序相反

# Unit 4 第一个程序

## 4.1 一个源程序从写出到执行的过程

  1. 编写汇编源程序

     结果：产生了一个存储源程序的文本文件（.asm）

  2. 使用汇编语言编译程序对源程序进行编译链接

     - 编译：产生目标文件（.obj）

     - 连接：生成可在操作系统中直接运行的可执行文件（.exe）

       - 可执行文件包含两部分内容：

         1. 程序（汇编指令翻译过来的机器码）和数据（源程序中定义的）

         2. 相关描述信息

  3. 在操作系统中，执行可执行文件中的程序

     操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关初始化（eg. CS:IP 指向第一条要执行的指令）

     **操作系统管理内存**

     然后由 **CPU 执行程序**

## 4.2 源程序

伪指令：由编译器执行

  - `段名 segment` & `段名 ends`： 定义一个段

    一个汇编程序是由多个段组成的

  - `end`： 一个汇编程序的结束标记；通知编译器程序入口的位置

  - `assume`： 假设某一段寄存器和程序中的一个用 `segment...ends` 定义的段相关联

    并没有设置特定的段寄存器，设置段寄存器的是操作系统

源程序 & 程序：

  - 源程序：源程序文件中的所有内容（伪指令，由编译器处理）

  - 程序：源程序中最终由计算机执行、处理的程序（汇编指令）

标号：

  - 一个标号指代一个地址 eg.段名

程序返回：

  - 定义：将 CPU 的控制权交还给使它得以运行的程序

  - 途径：使用 21 号中断的 4ch 号功能

    ```
    mov ax, 4C00H
    int 21H
    ```

程序错误

  - 语法错误：可被编译器发现

  - 逻辑错误：在运行时发生，不可被编译器发现

## 4.3 编辑源程序

用 edit，编辑程序后存为 xxx.asm

## 4.4 编译 && 4.5 连接

过程翻书吧 - -

连接的作用：

  1. 当源程序很大时，可以将它分为多个源程序文件来编译 → **模块化**

  2. 将程序调用的库文件和该程序生成的目标文件连接到一起

  3. 目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息

## 4.6 以简化的方式进行编译和链接

```
masm projname;
link projname;
```

## 4.8 谁将可执行文件中的程序装载进入内存并使它运行？

关于 shell：

  - 操作系统 - 提供 → shell

  - 用户 - shell → 操作计算机系统工作

  - DOS 的 shell：命令解释器 `command.com`

  - DOS 启动后，用户的命令由 command 执行

汇编程序从写出到执行的过程：

  1. **Edit** 下编程 → .asm

  2. **masm** 编译 → .obj

  3. **link** 连接 → .exe

  4. **command** 根据文件名找到可执行文件

  5. **command** 将可执行文件中的程序加载入内存，并设置 CS:IP 指向程序入口

  6. **CPU** 运行程序

  7. 程序返回到 **command** 中

## 4.9 程序执行过程的跟踪

`debug projname.exe`

DOS 中 .exe 文件中的程序的加载过程：

  1. 找到一段 **起始地址为 SA:0000 的** **容量足够** 的 **空闲** 内存区

  2. 在 **SA:0 - SA+10H:0** 创建 **程序段前缀（PSP）**

     DOS 利用 PSP 和被加载程序进行通信

  3. 在 SA+10H 后面将程序装入

     *PSP 和程序虽然物理地址连续，却有不同的段地址*

  4. DS = SA；

     初始化其他 reg；

     CS:IP = SA+10H:0

程序加载后，cx 中存放程序长度，ds 中存放程序所在内存区的段地址（偏移地址为 0）


# Unit 5 [BX] 和 loop 指令

内存单元的描述：地址、长度（类型）

（m）

  - 表示 m 中的内容

  - m = reg / sreg / 内存单元的物理地址（20 位）

idata： 表示常量

## 5.3 在 debug 中跟踪用 loop 指令实现的循环程序

默认数制：debug - 16进制；源程序 - 10进制

在汇编程序中，数据不能以字母开头（因为可能和 reg 中的字母搞混），故要在以字母开头的数据前加 0


## 5.4 Debug 和 masm 对指令的不同处理

对于 [idata]：
  - debug 将其解释为 [idata]，即 ds:idata
  - 编译器将其解释为 idata（故需显式地给出段寄存器）

## 5.6 段前缀

用于显式地指明内存单元的段地址，eg. `ds:`、`cs:`、`ss:`、`es:`

## 5.7 一段安全的空间

0:200 ~ 0:2ff （是中断向量表中的空闲部分）


# Unit 6 包含多个段的程序

程序获得所需空间的方法：

  - 加载程序的时候为程序分配

  - 程序在执行过程中向系统申请

## 6.1 在代码段中使用数据

数据的定义 / 内存空间的开辟：

  - `dw` = define word 定义字型数据

  - `dd` = define double word 定义双字型数据

  - `db` = define byte 定义字节型数据

  - `d_ 重复次数 dup (重复数据1, 重复数据2, ...)` 进行数据重复

在源程序中指明程序入口：用标号

```
assume cs:code
code segment
    dw ...
start:
    ...
code ends
end start
```

end 可以通知编译器程序的入口在什么地方

机制：在编译连接后，由 end ... 指明的程序入口，被转化为一个入口地址，存储在可执行文件的描述信息中，当程序被加载入内存之后，加载者读到该地址，设置 CS:IP

## 6.2 在代码段中使用栈

定义方法同数据，但要在程序中将 SS:SP 指向栈底

## 6.3 将数据、代码、栈放入不同的段

动机：

  - 把所有东西都放到一个段里很乱

  - 8086CPU 中，一个段的容量不能大于 64kb

不同的段要有不同的段名

## 实验 5 编写、调试具有多个段的程序

如果一个段中定义的数据不是 16byte 的整数倍，会用 0 凑整

把代码段放在最前面就可以不用标号指明程序入口啦

# Unit 7 更灵活地定位内存地址的方法

## 7.3 以字符形式给出的数据

用 `'...'` 的方式指明数据是以字符形式给出的，编译器将把它们转化为相对应的 ASCII 码

## 7.4 大小写转换的问题

将一个字母的第五位置 0，它必将变为大写字母

将一个字母的第五位置 1，它必将变为小写字母

## 7.10 不同的寻址方式的灵活应用

方式 | 介绍
:-: | :-:
[idata] | 直接定位
[bx] | 间接定位
[bx + idata] | 在一个起始地址的基础上间接定位（类似数组）
[bx + si] | 用于二重循环
[bx + si + idata] | 数组 + 二重循环

用 loop 进行多重循环时 cx 的设置：每次开始内层循环时保存外层循环中 cx 的值，用栈实现

**一般来说，在需要暂存数据的时候，我们都应该使用栈**


# Unit 8 数据处理的两个基本问题

## 8.1 bx si di bp

`[...]` 中进行内存单元的寻址时，可接受的形式：

```
默认 sreg = ds   ←   bx       si
                          +        +   idata
默认 sreg = ss   ←   bp       di
```

## 8.2 机器指令处理的数据在什么地方

指令执行前一刻，机器指令将要处理的数据所在的位置：

  - CPU 内部

    - reg

    - 指令缓冲器 - idata

  - 内存 - 段地址和偏移地址

  - 端口

因为 CPU 可以 **直接读写** 以上三个地方的数据

## 8.4 寻址方式

![寻址方式小结](/assets/2019-05-20-assem-01.png)

## 8.5 指令要处理的数据有多长

8086CPU 可以处理两种尺寸的数据：byte 和 word

指明数据尺寸的方法：

  1. 通过 reg

  2. 用操作符 `X ptr` 显式声明，X = word / byte

  3. 其他方法（有些指令默认了访问的是 word 还是 byte，比如 `push` ）


# Unit 9 转移指令的原理

可以修改 IP，或同时修改 CS 和 IP 的指令称为转移指令

8086 的转移距离

  - 段内转移：只修改 IP，修改范围为 -128 ~ 127

    - 短转移

    - 近转移

  - 段间转移 / 远转移：同时修改 CS 和 IP，修改范围为 -32768 ~ 32767

转移时要给出两种信息：

  - 目的地址

  - 距离

8086 的转移指令

  - 无条件转移指令（如 `jmp`）

  - 条件转移指令

  - 循环指令（如 `loop`）

  - 过程

  - 中断

## 9.1 操作符 offset

offset 

  - 功能：取得标号的偏移地址

  - 取值范围：0 - ffffh

  - 在编译阶段写定（段确定 → 偏移确定）

seg

  - 功能：取得标号的段地址

## 9.3 依据位移进行转移的 jmp 指令

机器码中不包括转移的目的地址，而是包含位移

`jmp x 标号` 的功能：(IP) = (IP) + 位移

  - 位移 = 标号处地址 - jmp 指令后的第一个字节的地址

    目标地址 - 原地址；是矢量

  - x = short → 短转移，8 位位移，范围为 -128 ~ 127，用补码表示

    x = near ptr → 近转移，16 位位移，范围为 -32768 ~ 32767，用补码表示

  - 位移由编译程序在编译时算出

## 9.4 && 9.5 && 9.6 转移的目的地址在指令 && reg && 内存中的 jmp 指令

机器码中包含转移的目的地址，是字型就只改 IP，是双字型就同时改 IP 和 CS

## 9.7 jcxz 指令

`jcxz 标号` 的功能：

  - 当 (CX) != 0 时，(IP) = (IP) + 8 位位移

    - 位移 = 标号处地址 - jcxz 后的第一个字节的地址

    - 8 位位移范围为 -128 ~ 127，用补码表示

    - 位移由编译程序在编译时算出

  - 当 (CX) == 0 时，什么也不做（程序向下执行）

~~用了很久才发现 jcxz 的直译是 jump CX zero 呀哈哈哈哈好暴力！~~

## 9.8 loop 指令

操作：

  1. (CX)--;

  2. 当 (CX) != 0 时，(IP) = (IP) + 8 位位移，位移细节同 jcxz

     当 (CX) == 0 时，什么也不做（程序向下执行）

## 9.9 根据位移进行转移的意义

方便了程序段在内存中的 **浮动装配**

## 9.10 编译器对转移位移超界的检测

如果超界，编译器会报错

## 实验 9 根据材料编程

80 x 25 彩色字符模式显示缓冲区的结构：

  - 内存：B8000H ~ BFFFFH 共 32kb，分为 8 页，每页 4kb

  - 在一页显示缓冲区中：

    偏移 X00 ~ X9F 对应显示器上的第 X 行

    一行有 80 个字符，一个字符占两个字节，分别存放字符的 ASCII 码和属性，共占 160 个字节

  - 属性字节的格式：

    位数  7   6   5   4   3   2   1   0

    含义  BL  R   G   B   I   R   G   B

    释义  闪烁    背景     高亮    前景

    闪烁效果在全屏 DOS 方式下才能看到


# Unit 10 CALL 和 RET 指令

这章就没什么好写啦，实现子程序嘛……

记得保护寄存器呀……


# Unit 11 标志寄存器

标志寄存器（flag）的作用：

  - 存储相关指令的某些执行结果

  - 为 CPU 执行相关指令提供行为依据

  - 控制 CPU 的相关工作方式

8086CPU 的标志寄存器有 16 位，其中存储的信息被称为程序状态字（PSW）

## 11.6 adc 指令

加法可以分两步运算：

  1. 低位相加

  2. 高位相加再加上低位相加产生的进位值

所以 adc 的目的是突破 16 位机运算位数的限制，实现任意大数据的加法运算，sbb 的思想是类似的

## 11.8 cmp 指令

cmp m, n

是否相等：取决于 zf

  - zf = 1 → m = n

  - zf = 0 → m != n

无符号数大小比较：取决于 cf

  - cf = 1 → m < n

  - cf = 0 → m > n

有符号数大小比较：取决于 sf，of

  实际结果：

  - sf = 1 → m < n

  - sf = 0 → m > n

  溢出：

  - of = 1 → 有溢出，真正结果与逻辑结果相反

  - of = 0 → 无溢出，真正结果与逻辑结果相同


# Unit 12 内中断

中断：CPU 不再接着（刚执行完的指令）向下执行，而是转去处理特殊信息

## 12.1 内中断的产生

**中断源**：产生中断信息的事件，即中断信息的来源

**中断类型码**：字节型数据，标识中断源

中断源 | 中断类型码
:-: | :-:
除法错误 | 0
单步执行 | 1
执行 into 指令 | 4
执行 int n | n

## 12.2 中断处理程序

**中断程序**：用来处理中断信息的程序

## 12.3 中断向量表

**中断向量**：中断处理程序的入口地址

**中断向量表**：中断处理程序入口地址的列表，在 8086CPU 中，放在 0000:0000 - 0000:03ff 中，高地址字存放段地址，低地址字存放偏移地址

## 12.4 中断过程

  1. 取得中断类型码 N

  2. pushf
  
  3. TF = 0, IF = 0

  4. push CS

  5. push IP

  6. (IP) = (N * 4), (CS) = (N * 4 + 2)

## 12.5 中断处理程序和 iret 指令

中断处理程序的常规步骤：

  1. 保存 reg

  2. 处理中断

  3. 恢复 reg

  4. 用 `iret` 返回

`iret` 指令的功能：

  1. pop IP

  2. pop CS

  3. popf

## 12.7 编程处理 0 号中断

安装程序应该做的两件事：

  1. 把程序送到安全内存空间中（用串传送指令）

  2. 设置中断向量表

数据和栈不能像以往那样单独定义成段，应该放在中断程序开头处，避免被覆盖

## 12.11 单步中断

CPU 提供单步中断的原因：为单步跟踪程序的执行过程提供了实现机制


# Unit 13 int 指令

## 13.4 BIOS 和 DOS 所提供的中断例程

BIOS 的组成：

  - 硬件系统的检测和初始化程序

  - 外部中断和内部中断的中断例程

  - 用于对硬件设备进行 I/O 操作的中断例程

  - 其他和硬件系统相关的中断例程

BIOS 的中断例程：和 **硬件设备** 相关

DOS 的中断例程：**操作系统** 向程序员提供的变成资源

## 13.5 BIOS 和 DOS 中断例程的安装过程

  1. CPU 加电，初始化 (CS) = 0FFFH, (IP) = 0

  2. CPU 执行 FFFF:0 处的转跳指令，转去 BIOS 中的硬件系统检测和初始化

  3. 初始化程序建立 BIOS 所支持的中断向量（即将 BIOS 提供的中断例程的入口地址登记在中断向量表中）

     它们是固化到 ROM 中的程序，一直在内存中存在，所以只要登记入口地址就好啦
  
  4. 硬件系统检测和初始化完成后，CPU 调用 int 19h 进行操作系统引导，从此将计算机交由操作系统控制

  5. DOS 将 DOS 的中断例程装入内存并建立相应的中断向量，并完成其它工作


# Unit 14 端口

和 CPU 通过总线相连的芯片：

  - 各种存储器

  - 通过端口操作其中寄存器的：（端口，统一编址 → 端口地址空间）

    - 各种接口卡上的接口芯片，用于控制接口卡工作

    - 主板上的接口芯片，用于访问部分外设

    - 其他芯片，用于存储相关的系统信息 or 进行相关的输入输出处理

## 14.1 端口的读写

端口地址通过内存地址一样通过地址总线来传送

CPU 最多可定位 64 个不同端口 → 端口地址范围为 0 ~ 65535

对端口的读写只能用 in / out 指令

in / out 指令执行时与总线相关的操作：

  1. CPU 通过 **地址线** 发出地址信息（端口号）

  2. CPU 通过 **控制线** 发出端口读 / 写命令，选中端口所在芯片，并通知它要从中读数据 / 向其写数据

  3. 端口所在芯片 与 CPU 通过 **数据线** 传送要读写的数据

## 14.2 CMOS RAM 芯片

CMOS RAM 芯片的特征：

  - **实时钟**

    - 该芯片靠电池供电，故关机后时钟仍可正常工作

  - 一个有 128 个存储单元的 **RAM**

    - 0 - 0dh 时间信息

    - others 保存系统配置信息，供系统启动 BIOS 时读取 or 程序员配置（BIOS 提供相关程序）
  
    - 两个端口

      - 70h 地址端口，存放要访问的 CMOS RAM 单元的地址

      - 71h 数据端口，存放从选定的单元中读取的数据 / 要写入的数据

CPU 对 CMOS RAM 的读写分两步进行：向地址端口中送入地址，与数据端口进行数据交互

## 14.4 CMOS RAM 中存储的时间信息

信息 | 存放单元
:-: | :-:
秒 | 0
分 | 2
时 | 4
日 | 7
月 | 8
年 | 9

长度均为 1 byte，以 BCD 码存放

BCD码：以 4 位二进制数表示十进制数码

一个字节可表示两个 BCD 码，所以读取时间信息的时候要用位运算把它拆开


# Unit 15 外中断

CPU 除了有运算能力外，还要有 I/O 能力

## 15.1 接口芯片和端口

CPU 通过端口和外设进行联系

## 15.2 外中断信息

外中断：由相关芯片发送至 CPU，CPU 在执行完当前指令后，检测终端信息，并引发中断过程，处理外设输入

外中断的中断类型码通过数据总线送入 CPU，内中断的中断类型码则是在 CPU 内部产生的，其余流程和内中断相同

外中断源

  - 可屏蔽中断：CPU 可以不响应的外中断，取决于 IF 位

    IF = 0 → 不响应

    IF = 1 → 响应

    所以中断过程中令 IF = 0 的目的是在进入中断处理程序后禁止其它的可屏蔽中断，也可用 sti（IF = 1) 或 cli(IF = 0) 手动设置

    几乎所有由外设引发的外中断都是可屏蔽中断

  - 不可屏蔽中断：CPU 必须相应的外中断，中断类型码固定为 2（不需取中断号）

    不可屏蔽中断是在系统中有必须处理的紧急情况时用来通知 CPU 的中断信息

## 15.3 PC 机键盘的处理过程

1. 键盘输入

  按下一个键 → 键盘中芯片产生扫描码（通码） → 送入主板上相关接口芯片的寄存器中（端口地址 = 60h）

  松开一个键 → 产生断码 = 通码 + 80h → 同上

  ![键盘上部分键的扫描码](/assets/2019-05-20-assem-02.png)

2. 引发 9 号中断

3. 执行 int 9 中断例程

  1. 读出 60h 端口中的扫描码

  2. 字符键 - 字符码 - 内存中的 BIOS **键盘缓冲区↓**
  
       键盘缓冲区：存储 15 个键盘输入，1 word / 输入，高位存放扫描码，低位存放字符码
     
     控制键 & 切换键 - 状态字节 - 内存中 **存储状态字节的单元** 
    
       存储键盘状态字节的单元：0040:17

       ```
       0: 右 shift = 1 → 按下
       1: 左 shift = 1 → 按下
       2: Ctrl = 1 → 按下
       3: Alt = 1 → 按下
       4: ScrollLock = 1 → 指示灯亮
       5: NumLock = 1 → 小键盘输入的是数字
       6: CapsLock = 1 → 大写字母
       7: Insert = 1 → 处于删除态
       ```
  
  3. 进行相关控制

## 15.4 编写 int 9 中断例程

模拟 int：

  1. pushf
  2. IF = 0, TF = 0
  3. call dword ptr ← 为避免在设置段地址和偏移地址的指令之间发生键盘中断，请活用 `sti` 和 `cli` ~


# Unit 16 直接定址表

## 16.1 描述了单元长度的标号

标号

  - 地址标号：仅仅表示内存地址

    `a: db 1, 2, 3, 4, 5, 6, 7, 8`

    `b: dw 0`

  - 数据标号：同时描述内存地址和单元长度

    `a db 1, 2, 3, 4, 5, 6, 7, 8`

    `b dw 0`

    这种标号可以代表一个段中的内存单元 eg. `mov ax, b` 中，标号 b 代表了一个内存单元，地址为 b 第一个元素的首地址，长度为 2 bytes

    支持用数组索引形式访问内存中的数据 eg. `mov al, a[si]`

## 16.2 在其他段中使用数据标号

地址标号只能在代码段中使用

如果想在代码段中直接用数据标号访问数据，需要用伪指令 assume 将标号所在的段和一个段寄存器联系起来，还要在代码段中用相应段寄存器指向相应段吼

## 16.3 直接定址表

利用表，在两个数据集合之间建立一种映射关系，使我们可以用查表的方法根据给出的数据得到其在另一集合中的对应数据

目的：

  1. 为了算法的清晰和简洁
  
  2. 为了加快运算速度

  3. 为了使程序易于扩充

## 16.4 程序入口地址的直接定址表

子程序的实现机制：我们可以在直接定址表中存储子程序的入口地址，它们在表中的位置和功能号相对应，从而方便地实现不同子程序的调用


# Unit 17 使用 BIOS 进行键盘输入和磁盘读写

## 17.1 int 9 中断例程对键盘输入的处理

键盘缓冲区

  - 16 个字单元，可以存储 15 个按键的扫描码和对应的 ASCII 码

  - 结构：环形队列

int 9 对键盘输入的处理：

  - 字符键：

    1. CPU 从 60h 端口读出键的通码

    2. 检测状态字节
    
    3. 根据状态字节将扫描码（高位）和 ASCII 码（低位）写入键盘缓冲区

  - 状态键：

    1. CPU 从 60h 端口读出键的通码

    2. 改写状态字节

## 17.2 使用 int 16h 中断例程读取键盘缓冲区

int 16h 的 0 号功能进行如下工作：

  1. 检测键盘缓冲区中是否有数据

  2. **没有则继续做第一步（循环等待）**

  3. 读取缓冲区中 **第一个** 字单元中的键盘输入

  4. 将读取的扫描码送入 ah，ASCII 码送入 al

  5. 将已读取的键盘输入从缓冲区中删除

## 17.4 应用 int 13h 中断例程对磁盘进行读写

3.5 英寸软盘：

  - 分上下两面，每面有 80 个磁道，每个磁道有 18 个扇区，每个扇区的大小为 512 字节

  - 磁盘的实际访问由磁盘控制器进行，我们只能以扇区为单位读写磁盘（用 int 13h）

  - 读写时要给出面号、磁道号和扇区号，面号和磁道号从 0 开始，扇区号从 1 开始

## 实验 17 编写包含多个功能子程序的中断例程

写逻辑扇区编号体现统一编址的好处呀 ~~






***

感想这种东西就悄悄附在文末……

虽然严格意义上来讲，写下这个文档的时候我还没完成第一阶段（毕竟还没做传说中的课设二……），但如果要我为这段日子做个总结的话，我会说，我没想到，在大一的热血青春之后，在这个方圆不超过两公里的校园内，竟然还能遇到如此美好的事。

最初是因为看到可以学汇编所以稀里糊涂地报了名，还差一点因为大冬天刮大风而没去启动会（？），现在想想，真是万幸我去了。宣讲的学长站在台上，把“独立”“强大”和“纯粹”说得那么坚定和恳切，我在台下听着，看着，几乎像个傻子一样热泪盈眶，我的人生至今为止，一直就是在踏进各式各样的校门，受各式各样的教育，以至于对受教育这事都快要变得麻木了，但那一夜我心里的某些东西松动了，因为从没有人对我说过那些话，做过那般热忱的讲演，宣讲的学长说“也许你们有的人在想，终于有人大声地把这些说出来了”，其实我在想的是，终于有人在我眼前鲜活地证明了这些话是可以被说出来的，不仅可以说出来，还可以无畏地付诸实践。

之后……就是学习活动啦，没啥好说的，都在笔记里了，就有一点，我意外地发现，我对随堂考试和上台讲课竟然也没有抵触或者恐惧，虽然没有提前完成进度，但也没有被丢在后面，一切都自然而然地完成了，每每想到这里，我总是十分惶恐，在这“顺利”背后，得有多少人的付出呀。

希望我还能在这里变得更强大一些，能在知识当中汲取更多，然后，不要当程序员（诶）。最后还有一句，是第一阶段的学长走之前说的：“你们明明还什么都没做”。以此自勉吧。